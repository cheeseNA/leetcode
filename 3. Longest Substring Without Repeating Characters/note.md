# step1

time: 36:36

naive な方法では O(N^3).
しゃくとり法？ちがうか.

各文字に対して各位置でのそれまでの出現回数を持っておけば, 26 回で妥当かチェックできる, よって O(N^2)に削減可能.

始まりの位置を固定したときに, 終わりの位置は重複が生じるまでできるだけ伸ばせばそれが最長のものとなる. それならば累積和ではなく set をもつことで管理可能だ. ある始まりの位置に対して最善の終わりの位置がわかったら, 次は始まりの位置を重複が解消されるまで前にずらしていく. 解消されたら今度は後ろを伸ばす. これで time complexity は O(N), space complexity は O(1).

実装では, end_index が終端のときの処理がややこしい…
また, start_index, end_index の位置がシュミレーションしにくい. 思ったように動かず print デバッグをしてしまった.
while の内部にしか return が無いのが気になる. また, while True をまた使用してしまっている. しゃくとり法の実装に慣れたい.

# step2
