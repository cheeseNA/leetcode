# step1

inplace で操作すれば良いのかどうか不明.
型が -> Optional[ListNode]となっているので, inplace ではなく新しく作る方針で解く.
と思ったが, inplace で行う方針だと実装方法がかなり変わると思うので, そちらも実装する.

inplace での実装時, `current_tail.next = None`を忘れてしまっていた. テストケースを動かして確認するのを忘れずに行う.

# step2

見た解答

- google docs の sample answer
  - 同じノードが隣り合っていない場合のみ cursor を動かせば, 3 個以上同じノードが連続している場合にも対応できる.
- https://discord.com/channels/1084280443945353267/1195700948786491403/1196388760275910747
  - このように二重で while を回すほうが直感的.
  - Haskell で実装すると`concatMap (take 1) group <linked list>`という形で実装できるらしい.
- https://discord.com/channels/1084280443945353267/1201211204547383386/1201574642649923624
- https://discord.com/channels/1084280443945353267/1192736784354918470/1199759433543200819
  - seeking_next という命名は良い.
  - "相手が受け取るときの手間を考えるのが、エンジニアリングの本質です。"
    - 気をつけます
- https://discord.com/channels/1084280443945353267/1200089668901937312/1206126692431822899
  - current_node を while の最初で変更しているのが良くないという指摘があり, その通りだと思う.

上記からとれる選択肢が様々あることが分かった. 今回は二重 while で実装することにする.
step1 に比べ格段にわかりやすくなった.
